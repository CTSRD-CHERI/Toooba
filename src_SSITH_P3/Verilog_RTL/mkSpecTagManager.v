//
// Generated by Bluespec Compiler (build 39ae402)
//
//
//
//
// Ports:
// Name                         I/O  size props
// currentSpecBits                O     4
// RDY_currentSpecBits            O     1 const
// nextSpecTag                    O     2
// RDY_nextSpecTag                O     1
// RDY_claimSpecTag               O     1
// canClaim                       O     1
// RDY_canClaim                   O     1 const
// RDY_specUpdate_incorrectSpeculation  O     1 const
// RDY_specUpdate_correctSpeculation  O     1 const
// isFull_ehrPort0                O     1
// RDY_isFull_ehrPort0            O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// specUpdate_incorrectSpeculation_kill_all  I     1
// specUpdate_incorrectSpeculation_kill_tag  I     2
// specUpdate_correctSpeculation_mask  I     4
// EN_claimSpecTag                I     1
// EN_specUpdate_incorrectSpeculation  I     1
// EN_specUpdate_correctSpeculation  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkSpecTagManager(CLK,
			RST_N,

			currentSpecBits,
			RDY_currentSpecBits,

			nextSpecTag,
			RDY_nextSpecTag,

			EN_claimSpecTag,
			RDY_claimSpecTag,

			canClaim,
			RDY_canClaim,

			specUpdate_incorrectSpeculation_kill_all,
			specUpdate_incorrectSpeculation_kill_tag,
			EN_specUpdate_incorrectSpeculation,
			RDY_specUpdate_incorrectSpeculation,

			specUpdate_correctSpeculation_mask,
			EN_specUpdate_correctSpeculation,
			RDY_specUpdate_correctSpeculation,

			isFull_ehrPort0,
			RDY_isFull_ehrPort0);
  input  CLK;
  input  RST_N;

  // value method currentSpecBits
  output [3 : 0] currentSpecBits;
  output RDY_currentSpecBits;

  // value method nextSpecTag
  output [1 : 0] nextSpecTag;
  output RDY_nextSpecTag;

  // action method claimSpecTag
  input  EN_claimSpecTag;
  output RDY_claimSpecTag;

  // value method canClaim
  output canClaim;
  output RDY_canClaim;

  // action method specUpdate_incorrectSpeculation
  input  specUpdate_incorrectSpeculation_kill_all;
  input  [1 : 0] specUpdate_incorrectSpeculation_kill_tag;
  input  EN_specUpdate_incorrectSpeculation;
  output RDY_specUpdate_incorrectSpeculation;

  // action method specUpdate_correctSpeculation
  input  [3 : 0] specUpdate_correctSpeculation_mask;
  input  EN_specUpdate_correctSpeculation;
  output RDY_specUpdate_correctSpeculation;

  // value method isFull_ehrPort0
  output isFull_ehrPort0;
  output RDY_isFull_ehrPort0;

  // signals for module outputs
  wire [3 : 0] currentSpecBits;
  wire [1 : 0] nextSpecTag;
  wire RDY_canClaim,
       RDY_claimSpecTag,
       RDY_currentSpecBits,
       RDY_isFull_ehrPort0,
       RDY_nextSpecTag,
       RDY_specUpdate_correctSpeculation,
       RDY_specUpdate_incorrectSpeculation,
       canClaim,
       isFull_ehrPort0;

  // inlined wires
  wire current_spec_bits_ehr_lat_0$whas, wrongSpec_claim_conflict$whas;

  // register current_spec_bits_ehr_rl
  reg [3 : 0] current_spec_bits_ehr_rl;
  wire [3 : 0] current_spec_bits_ehr_rl$D_IN;
  wire current_spec_bits_ehr_rl$EN;

  // register dependent_checkpoints_0
  reg [3 : 0] dependent_checkpoints_0;
  wire [3 : 0] dependent_checkpoints_0$D_IN;
  wire dependent_checkpoints_0$EN;

  // register dependent_checkpoints_1
  reg [3 : 0] dependent_checkpoints_1;
  wire [3 : 0] dependent_checkpoints_1$D_IN;
  wire dependent_checkpoints_1$EN;

  // register dependent_checkpoints_2
  reg [3 : 0] dependent_checkpoints_2;
  wire [3 : 0] dependent_checkpoints_2$D_IN;
  wire dependent_checkpoints_2$EN;

  // register dependent_checkpoints_3
  reg [3 : 0] dependent_checkpoints_3;
  wire [3 : 0] dependent_checkpoints_3$D_IN;
  wire dependent_checkpoints_3$EN;

  // ports of submodule current_spec_bits_ehr_dummy2_0
  wire current_spec_bits_ehr_dummy2_0$D_IN,
       current_spec_bits_ehr_dummy2_0$EN,
       current_spec_bits_ehr_dummy2_0$Q_OUT;

  // ports of submodule current_spec_bits_ehr_dummy2_1
  wire current_spec_bits_ehr_dummy2_1$D_IN,
       current_spec_bits_ehr_dummy2_1$EN,
       current_spec_bits_ehr_dummy2_1$Q_OUT;

  // rule scheduling signals
  wire CAN_FIRE_RL_current_spec_bits_ehr_canon,
       CAN_FIRE_RL_debugSt,
       CAN_FIRE_claimSpecTag,
       CAN_FIRE_specUpdate_correctSpeculation,
       CAN_FIRE_specUpdate_incorrectSpeculation,
       WILL_FIRE_RL_current_spec_bits_ehr_canon,
       WILL_FIRE_RL_debugSt,
       WILL_FIRE_claimSpecTag,
       WILL_FIRE_specUpdate_correctSpeculation,
       WILL_FIRE_specUpdate_incorrectSpeculation;

  // inputs to muxes for submodule ports
  wire [3 : 0] MUX_current_spec_bits_ehr_lat_0$wset_1__VAL_1,
	       MUX_current_spec_bits_ehr_lat_0$wset_1__VAL_2;

  // remaining internal signals
  reg [3 : 0] x__h3635;
  wire [3 : 0] IF_current_spec_bits_ehr_lat_0_whas_THEN_curre_ETC___d6,
	       _dfoo16,
	       _dfoo18,
	       _dfoo2,
	       _dfoo20,
	       _dfoo6,
	       _dfoo8,
	       n__read__h3771,
	       upd__h1000,
	       upd__h3863,
	       w__h1843,
	       x__h2165,
	       x__h2323,
	       x__h2643,
	       x__h2963,
	       x__h3283,
	       x__h3593,
	       y__h3634;
  wire [1 : 0] valid_spec_tag__h1793;

  // value method currentSpecBits
  assign currentSpecBits =
	     (current_spec_bits_ehr_dummy2_0$Q_OUT &&
	      current_spec_bits_ehr_dummy2_1$Q_OUT) ?
	       current_spec_bits_ehr_rl :
	       4'd0 ;
  assign RDY_currentSpecBits = 1'd1 ;

  // value method nextSpecTag
  assign nextSpecTag =
	     w__h1843[0] ?
	       (w__h1843[1] ? (w__h1843[2] ? 2'd3 : 2'd2) : 2'd1) :
	       2'd0 ;
  assign RDY_nextSpecTag = canClaim ;

  // action method claimSpecTag
  assign RDY_claimSpecTag = canClaim ;
  assign CAN_FIRE_claimSpecTag = canClaim ;
  assign WILL_FIRE_claimSpecTag = EN_claimSpecTag ;

  // value method canClaim
  assign canClaim =
	     !w__h1843[0] || !w__h1843[1] || !w__h1843[2] || !w__h1843[3] ;
  assign RDY_canClaim = 1'd1 ;

  // action method specUpdate_incorrectSpeculation
  assign RDY_specUpdate_incorrectSpeculation = 1'd1 ;
  assign CAN_FIRE_specUpdate_incorrectSpeculation = 1'd1 ;
  assign WILL_FIRE_specUpdate_incorrectSpeculation =
	     EN_specUpdate_incorrectSpeculation ;

  // action method specUpdate_correctSpeculation
  assign RDY_specUpdate_correctSpeculation = 1'd1 ;
  assign CAN_FIRE_specUpdate_correctSpeculation = 1'd1 ;
  assign WILL_FIRE_specUpdate_correctSpeculation =
	     EN_specUpdate_correctSpeculation ;

  // value method isFull_ehrPort0
  assign isFull_ehrPort0 =
	     w__h1843[0] && w__h1843[1] && w__h1843[2] && w__h1843[3] ;
  assign RDY_isFull_ehrPort0 = 1'd1 ;

  // submodule current_spec_bits_ehr_dummy2_0
  RevertReg #(.width(32'd1),
	      .init(1'd1)) current_spec_bits_ehr_dummy2_0(.CLK(CLK),
							  .D_IN(current_spec_bits_ehr_dummy2_0$D_IN),
							  .EN(current_spec_bits_ehr_dummy2_0$EN),
							  .Q_OUT(current_spec_bits_ehr_dummy2_0$Q_OUT));

  // submodule current_spec_bits_ehr_dummy2_1
  RevertReg #(.width(32'd1),
	      .init(1'd1)) current_spec_bits_ehr_dummy2_1(.CLK(CLK),
							  .D_IN(current_spec_bits_ehr_dummy2_1$D_IN),
							  .EN(current_spec_bits_ehr_dummy2_1$EN),
							  .Q_OUT(current_spec_bits_ehr_dummy2_1$Q_OUT));

  // rule RL_debugSt
  assign CAN_FIRE_RL_debugSt = 1'd1 ;
  assign WILL_FIRE_RL_debugSt = 1'd1 ;

  // rule RL_current_spec_bits_ehr_canon
  assign CAN_FIRE_RL_current_spec_bits_ehr_canon = 1'd1 ;
  assign WILL_FIRE_RL_current_spec_bits_ehr_canon = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_current_spec_bits_ehr_lat_0$wset_1__VAL_1 = w__h1843 | x__h2165 ;
  assign MUX_current_spec_bits_ehr_lat_0$wset_1__VAL_2 =
	     specUpdate_incorrectSpeculation_kill_all ? 4'd0 : x__h3593 ;

  // inlined wires
  assign current_spec_bits_ehr_lat_0$whas =
	     EN_claimSpecTag || EN_specUpdate_incorrectSpeculation ;
  assign wrongSpec_claim_conflict$whas =
	     EN_specUpdate_incorrectSpeculation || EN_claimSpecTag ;

  // register current_spec_bits_ehr_rl
  assign current_spec_bits_ehr_rl$D_IN =
	     EN_specUpdate_correctSpeculation ?
	       upd__h1000 :
	       IF_current_spec_bits_ehr_lat_0_whas_THEN_curre_ETC___d6 ;
  assign current_spec_bits_ehr_rl$EN = 1'd1 ;

  // register dependent_checkpoints_0
  assign dependent_checkpoints_0$D_IN = w__h1843[0] ? x__h2323 : x__h2165 ;
  assign dependent_checkpoints_0$EN =
	     EN_claimSpecTag &&
	     (w__h1843[0] || valid_spec_tag__h1793 == 2'd0 && !w__h1843[0] ||
	      valid_spec_tag__h1793 == 2'd0 && w__h1843[0] && !w__h1843[1] ||
	      valid_spec_tag__h1793 == 2'd0 && w__h1843[0] && w__h1843[1]) ;

  // register dependent_checkpoints_1
  assign dependent_checkpoints_1$D_IN =
	     (valid_spec_tag__h1793 == 2'd1 && !w__h1843[0]) ?
	       x__h2165 :
	       _dfoo20 ;
  assign dependent_checkpoints_1$EN =
	     EN_claimSpecTag &&
	     (valid_spec_tag__h1793 == 2'd1 && !w__h1843[0] ||
	      valid_spec_tag__h1793 == 2'd1 && w__h1843[0] && !w__h1843[1] ||
	      w__h1843[1]) ;

  // register dependent_checkpoints_2
  assign dependent_checkpoints_2$D_IN =
	     (valid_spec_tag__h1793 == 2'd2 && !w__h1843[0]) ?
	       x__h2165 :
	       _dfoo18 ;
  assign dependent_checkpoints_2$EN =
	     EN_claimSpecTag &&
	     (valid_spec_tag__h1793 == 2'd2 && !w__h1843[0] ||
	      valid_spec_tag__h1793 == 2'd2 && w__h1843[0] && !w__h1843[1] ||
	      valid_spec_tag__h1793 == 2'd2 && w__h1843[0] && w__h1843[1] &&
	      !w__h1843[2] ||
	      w__h1843[2]) ;

  // register dependent_checkpoints_3
  assign dependent_checkpoints_3$D_IN =
	     (valid_spec_tag__h1793 == 2'd3 && !w__h1843[0]) ?
	       x__h2165 :
	       _dfoo16 ;
  assign dependent_checkpoints_3$EN =
	     EN_claimSpecTag &&
	     (valid_spec_tag__h1793 == 2'd3 && !w__h1843[0] ||
	      valid_spec_tag__h1793 == 2'd3 && w__h1843[0] && !w__h1843[1] ||
	      valid_spec_tag__h1793 == 2'd3 && w__h1843[0] && w__h1843[1] &&
	      !w__h1843[2] ||
	      valid_spec_tag__h1793 == 2'd3 && w__h1843[0] && w__h1843[1] &&
	      w__h1843[2] ||
	      (!w__h1843[0] || !w__h1843[1] || !w__h1843[2]) && w__h1843[3]) ;

  // submodule current_spec_bits_ehr_dummy2_0
  assign current_spec_bits_ehr_dummy2_0$D_IN = 1'd1 ;
  assign current_spec_bits_ehr_dummy2_0$EN = wrongSpec_claim_conflict$whas ;

  // submodule current_spec_bits_ehr_dummy2_1
  assign current_spec_bits_ehr_dummy2_1$D_IN = 1'd1 ;
  assign current_spec_bits_ehr_dummy2_1$EN =
	     EN_specUpdate_correctSpeculation ;

  // remaining internal signals
  assign IF_current_spec_bits_ehr_lat_0_whas_THEN_curre_ETC___d6 =
	     current_spec_bits_ehr_lat_0$whas ?
	       upd__h3863 :
	       current_spec_bits_ehr_rl ;
  assign _dfoo16 =
	     (valid_spec_tag__h1793 == 2'd3 && w__h1843[0] && !w__h1843[1]) ?
	       x__h2165 :
	       _dfoo6 ;
  assign _dfoo18 =
	     (valid_spec_tag__h1793 == 2'd2 && w__h1843[0] && !w__h1843[1]) ?
	       x__h2165 :
	       _dfoo8 ;
  assign _dfoo2 =
	     (valid_spec_tag__h1793 == 2'd3 && w__h1843[0] && w__h1843[1] &&
	      w__h1843[2]) ?
	       x__h2165 :
	       x__h3283 ;
  assign _dfoo20 =
	     (valid_spec_tag__h1793 == 2'd1 && w__h1843[0] && !w__h1843[1]) ?
	       x__h2165 :
	       (w__h1843[1] ? x__h2643 : x__h2165) ;
  assign _dfoo6 =
	     (valid_spec_tag__h1793 == 2'd3 && w__h1843[0] && w__h1843[1] &&
	      !w__h1843[2]) ?
	       x__h2165 :
	       _dfoo2 ;
  assign _dfoo8 =
	     (valid_spec_tag__h1793 == 2'd2 && w__h1843[0] && w__h1843[1] &&
	      !w__h1843[2]) ?
	       x__h2165 :
	       (w__h1843[2] ? x__h2963 : x__h2165) ;
  assign n__read__h3771 =
	     current_spec_bits_ehr_dummy2_1$Q_OUT ?
	       IF_current_spec_bits_ehr_lat_0_whas_THEN_curre_ETC___d6 :
	       4'd0 ;
  assign upd__h1000 = n__read__h3771 & specUpdate_correctSpeculation_mask ;
  assign upd__h3863 =
	     EN_claimSpecTag ?
	       MUX_current_spec_bits_ehr_lat_0$wset_1__VAL_1 :
	       MUX_current_spec_bits_ehr_lat_0$wset_1__VAL_2 ;
  assign valid_spec_tag__h1793 =
	     w__h1843[0] ?
	       (w__h1843[1] ? (w__h1843[2] ? 2'd3 : 2'd2) : 2'd1) :
	       2'd0 ;
  assign w__h1843 =
	     (current_spec_bits_ehr_dummy2_0$Q_OUT &&
	      current_spec_bits_ehr_dummy2_1$Q_OUT) ?
	       current_spec_bits_ehr_rl :
	       4'd0 ;
  assign x__h2165 = 4'd1 << valid_spec_tag__h1793 ;
  assign x__h2323 = dependent_checkpoints_0 | x__h2165 ;
  assign x__h2643 = dependent_checkpoints_1 | x__h2165 ;
  assign x__h2963 = dependent_checkpoints_2 | x__h2165 ;
  assign x__h3283 = dependent_checkpoints_3 | x__h2165 ;
  assign x__h3593 = w__h1843 & y__h3634 ;
  assign y__h3634 = ~x__h3635 ;
  always@(specUpdate_incorrectSpeculation_kill_tag or
	  dependent_checkpoints_0 or
	  dependent_checkpoints_1 or
	  dependent_checkpoints_2 or dependent_checkpoints_3)
  begin
    case (specUpdate_incorrectSpeculation_kill_tag)
      2'd0: x__h3635 = dependent_checkpoints_0;
      2'd1: x__h3635 = dependent_checkpoints_1;
      2'd2: x__h3635 = dependent_checkpoints_2;
      2'd3: x__h3635 = dependent_checkpoints_3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        current_spec_bits_ehr_rl <= `BSV_ASSIGNMENT_DELAY 4'd0;
	dependent_checkpoints_0 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	dependent_checkpoints_1 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	dependent_checkpoints_2 <= `BSV_ASSIGNMENT_DELAY 4'd0;
	dependent_checkpoints_3 <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (current_spec_bits_ehr_rl$EN)
	  current_spec_bits_ehr_rl <= `BSV_ASSIGNMENT_DELAY
	      current_spec_bits_ehr_rl$D_IN;
	if (dependent_checkpoints_0$EN)
	  dependent_checkpoints_0 <= `BSV_ASSIGNMENT_DELAY
	      dependent_checkpoints_0$D_IN;
	if (dependent_checkpoints_1$EN)
	  dependent_checkpoints_1 <= `BSV_ASSIGNMENT_DELAY
	      dependent_checkpoints_1$D_IN;
	if (dependent_checkpoints_2$EN)
	  dependent_checkpoints_2 <= `BSV_ASSIGNMENT_DELAY
	      dependent_checkpoints_2$D_IN;
	if (dependent_checkpoints_3$EN)
	  dependent_checkpoints_3 <= `BSV_ASSIGNMENT_DELAY
	      dependent_checkpoints_3$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    current_spec_bits_ehr_rl = 4'hA;
    dependent_checkpoints_0 = 4'hA;
    dependent_checkpoints_1 = 4'hA;
    dependent_checkpoints_2 = 4'hA;
    dependent_checkpoints_3 = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (w__h1843[0] && w__h1843[1] && w__h1843[2] && w__h1843[3])
	$fdisplay(32'h80000001, "SpecTag manager locked");
  end
  // synopsys translate_on
endmodule  // mkSpecTagManager

